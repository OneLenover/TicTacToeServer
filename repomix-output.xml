This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
.gitignore
TicTacToeServer.slnx
TicTacToeServer/appsettings.json
TicTacToeServer/Program.cs
TicTacToeServer/Protos/GameService.proto
TicTacToeServer/TicTacToeServer.csproj
TicTacToeServer/UltimateGameLogic.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
###############################################################################
# Set default behavior to automatically normalize line endings.
###############################################################################
* text=auto

###############################################################################
# Set default behavior for command prompt diff.
#
# This is need for earlier builds of msysgit that does not have it on by
# default for csharp files.
# Note: This is only used by command line
###############################################################################
#*.cs     diff=csharp

###############################################################################
# Set the merge driver for project and solution files
#
# Merging from the command prompt will add diff markers to the files if there
# are conflicts (Merging from VS is not affected by the settings below, in VS
# the diff markers are never inserted). Diff markers may cause the following 
# file extensions to fail to load in VS. An alternative would be to treat
# these files as binary and thus will always conflict and require user
# intervention with every merge. To do so, just uncomment the entries below
###############################################################################
#*.sln       merge=binary
#*.csproj    merge=binary
#*.vbproj    merge=binary
#*.vcxproj   merge=binary
#*.vcproj    merge=binary
#*.dbproj    merge=binary
#*.fsproj    merge=binary
#*.lsproj    merge=binary
#*.wixproj   merge=binary
#*.modelproj merge=binary
#*.sqlproj   merge=binary
#*.wwaproj   merge=binary

###############################################################################
# behavior for image files
#
# image files are treated as binary by default.
###############################################################################
#*.jpg   binary
#*.png   binary
#*.gif   binary

###############################################################################
# diff behavior for common document formats
# 
# Convert binary document formats to text before diffing them. This feature
# is only available from the command line. Turn it on by uncommenting the 
# entries below.
###############################################################################
#*.doc   diff=astextplain
#*.DOC   diff=astextplain
#*.docx  diff=astextplain
#*.DOCX  diff=astextplain
#*.dot   diff=astextplain
#*.DOT   diff=astextplain
#*.pdf   diff=astextplain
#*.PDF   diff=astextplain
#*.rtf   diff=astextplain
#*.RTF   diff=astextplain
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Oo]ut/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd
</file>

<file path="TicTacToeServer.slnx">
<Solution>
  <Project Path="TicTacToeServer/TicTacToeServer.csproj" />
</Solution>
</file>

<file path="TicTacToeServer/appsettings.json">
{
  "ConsulAddress": "http://127.0.0.1:8500",
  "port": 5001,
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  }
}
</file>

<file path="TicTacToeServer/Protos/GameService.proto">
syntax = "proto3";

option csharp_namespace = "TicTacToe.App.Protos";

service GameService {
    rpc CreateGame (CreateRequest) returns (GameResponse);
    rpc MakeMove (MoveRequest) returns (GameResponse);
    rpc GetState (StateRequest) returns (GameResponse);
    rpc CheckSession (CheckRequest) returns (CheckResponse);
    rpc ResetGame (StateRequest) returns (GameResponse);
    rpc ExitGame (ExitRequest) returns (ExitResponse);
}

message CheckRequest {
    string playerId = 1;
}

message CheckResponse {
    string gameId = 1;
    bool exists = 2;
}

message CreateRequest {
    string playerId = 1; // Формат "Nickname|RoomID"
}

message StateRequest {
    string gameId = 1;
    string playerId = 2; 
}

message MoveRequest {
    string gameId = 1;
    string playerId = 2;
    int32 boardX = 3;
    int32 boardY = 4;
    int32 cellX = 5;
    int32 cellY = 6;
}

message ExitRequest {
    string gameId = 1;
    string playerId = 2;
}

message ExitResponse {
    bool success = 1;
}

message GameResponse {
    string gameId = 1;
    string fullBoard = 2;
    string smallBoardWinners = 3;
    string currentPlayerId = 4;
    string status = 5;
    int32 activeBoardX = 6;      
    int32 activeBoardY = 7;
    string error = 8;
    string playerX = 9;  // Добавлено поле
    string playerO = 10; // Добавлено поле
}
</file>

<file path="TicTacToeServer/UltimateGameLogic.cs">
namespace TicTacToeServer.Logic
{
    public class UltimateGameLogic
    {
        public char[] Cells { get; set; } = Enumerable.Repeat('.', 81).ToArray();
        public char[] SmallWinners { get; set; } = Enumerable.Repeat('.', 9).ToArray();
        public int ActiveBoardX { get; set; } = -1;
        public int ActiveBoardY { get; set; } = -1;
        public string PlayerX { get; set; } = "";
        public string PlayerO { get; set; } = ""; 
        public bool IsXTurn { get; set; } = true;
        public string Status { get; set; } = "Playing";

        public bool ValidMove(int bX, int bY, int cX, int cY, string pId)
        {
            if (Status != "Playing") return false;
            
            string expectedId = IsXTurn ? PlayerX : PlayerO;
            if (pId != expectedId) return false;

            if (ActiveBoardX != -1 && (bX != ActiveBoardX || bY != ActiveBoardY)) return false;
            if (SmallWinners[bY * 3 + bX] != '.') return false;
            if (Cells[(bY * 3 + cY) * 9 + (bX * 3 + cX)] != '.') return false;
            return true;
        }

        public void MakeMove(int bX, int bY, int cX, int cY)
        {
            char symbol = IsXTurn ? 'X' : 'O';
            Cells[(bY * 3 + cY) * 9 + (bX * 3 + cX)] = symbol;

            if (CheckWin(GetSmallBoard(bX, bY))) 
                SmallWinners[bY * 3 + bX] = symbol;

            if (SmallWinners[cY * 3 + cX] == '.' && GetSmallBoard(cX, cY).Contains('.'))
            {
                ActiveBoardX = cX; ActiveBoardY = cY;
            }
            else
            {
                ActiveBoardX = -1; ActiveBoardY = -1;
            }

            if (CheckWin(SmallWinners)) 
                Status = symbol == 'X' ? "X_Won" : "O_Won";
            else if (!Cells.Contains('.')) 
                Status = "Draw";

            IsXTurn = !IsXTurn;
        }

        private char[] GetSmallBoard(int bX, int bY)
        {
            char[] b = new char[9];
            for (int y = 0; y < 3; y++)
                for (int x = 0; x < 3; x++)
                    b[y * 3 + x] = Cells[(bY * 3 + y) * 9 + (bX * 3 + x)];
            return b;
        }

        private bool CheckWin(char[] b)
        {
            int[][] w = { new[] {0,1,2}, new[] {3,4,5}, new[] {6,7,8}, new[] {0,3,6}, new[] {1,4,7}, new[] {2,5,8}, new[] {0,4,8}, new[] {2,4,6} };
            return w.Any(p => b[p[0]] != '.' && b[p[0]] == b[p[1]] && b[p[0]] == b[p[2]]);
        }
    }
}
</file>

<file path="TicTacToeServer/Program.cs">
using Grpc.Core;
using TicTacToe.App.Protos;
using TicTacToeServer.Logic;
using Npgsql;
using Consul;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using System.Net;
using System.Net.Sockets;

var builder = WebApplication.CreateBuilder(args);

// Настройки порта и адреса Consul
var port = builder.Configuration.GetValue<int>("port", 5001);
var consulAddr = builder.Configuration.GetValue<string>("ConsulAddress") ?? "http://localhost:8500";

builder.WebHost.ConfigureKestrel(options =>
{
    options.ListenAnyIP(port, listenOptions =>
    {
        listenOptions.Protocols = HttpProtocols.Http2;
        listenOptions.UseHttps();
    });
});

builder.Services.AddGrpc();

var app = builder.Build();
app.MapGrpcService<GameServiceImpl>();

app.Lifetime.ApplicationStarted.Register(async () =>
{
    try
    {
        var consul = new ConsulClient(c => c.Address = new Uri(consulAddr));
        var hostIp = GetLocalIPAddress();

        var serviceId = $"tictactoe-{port}";

        Console.WriteLine($"[Consul] Регистрация сервиса {serviceId} на {hostIp}:{port} (Consul: {consulAddr})");

        await consul.Agent.ServiceRegister(new AgentServiceRegistration
        {
            ID = serviceId,
            Name = "tictactoe-service",
            Address = hostIp,
            Port = port,
            Check = new AgentServiceCheck
            {
                TCP = $"{hostIp}:{port}",
                Interval = TimeSpan.FromSeconds(5),
                DeregisterCriticalServiceAfter = TimeSpan.FromMinutes(1)
            }
        });
    }
    catch (Exception ex)
    {
        Console.WriteLine($"[Consul Error] {ex.Message}");
    }
});

app.Run();

static string GetLocalIPAddress()
{
    var host = Dns.GetHostEntry(Dns.GetHostName());
    foreach (var ip in host.AddressList)
        if (ip.AddressFamily == AddressFamily.InterNetwork && !ip.ToString().StartsWith("127."))
            return ip.ToString();
    return "127.0.0.1";
}

public class GameServiceImpl : GameService.GameServiceBase
{
    private const string ConnStr = "Host=localhost;Port=5433;Username=postgres;Password=mysecretpassword;Database=postgres";

    public override async Task<CheckResponse> CheckSession(CheckRequest r, ServerCallContext c)
    {
        using var conn = new NpgsqlConnection(ConnStr);
        await conn.OpenAsync();
        using var cmd = new NpgsqlCommand("SELECT game_id FROM games WHERE player_x = @p OR player_o = @p LIMIT 1", conn);
        cmd.Parameters.AddWithValue("p", r.PlayerId);
        var result = await cmd.ExecuteScalarAsync();

        return new CheckResponse
        {
            Exists = result != null,
            GameId = result?.ToString() ?? ""
        };
    }

    public override async Task<GameResponse> CreateGame(CreateRequest r, ServerCallContext c)
    {
        var parts = r.PlayerId.Split('|');
        if (parts.Length < 2) return new GameResponse { Error = "Invalid PlayerId format" };
        var nick = parts[0];
        var roomId = parts[1];

        var g = await Load(roomId);

        if (g == null)
        {
            g = new UltimateGameLogic { PlayerX = nick, PlayerO = "" };
        }
        else
        {
            if (g.PlayerX == nick || g.PlayerO == nick) return Map(roomId, g);
            if (string.IsNullOrWhiteSpace(g.PlayerX)) g.PlayerX = nick;
            else if (string.IsNullOrWhiteSpace(g.PlayerO)) g.PlayerO = nick;
        }

        await Save(roomId, g);
        return Map(roomId, g);
    }

    public override async Task<GameResponse> ResetGame(StateRequest r, ServerCallContext c)
    {
        var g = await Load(r.GameId);
        if (g == null) return new GameResponse { Error = "Room not found" };

        var newLogic = new UltimateGameLogic
        {
            PlayerX = g.PlayerX,
            PlayerO = g.PlayerO,
            Status = "Playing"
        };

        await Save(r.GameId, newLogic);
        return Map(r.GameId, newLogic);
    }

    public override async Task<ExitResponse> ExitGame(ExitRequest r, ServerCallContext c)
    {
        var g = await Load(r.GameId);
        if (g != null)
        {
            if (g.PlayerX == r.PlayerId) g.PlayerX = "";
            else if (g.PlayerO == r.PlayerId) g.PlayerO = "";

            if (string.IsNullOrEmpty(g.PlayerX) && string.IsNullOrEmpty(g.PlayerO))
            {
                using var conn = new NpgsqlConnection(ConnStr);
                await conn.OpenAsync();
                using var cmd = new NpgsqlCommand("DELETE FROM games WHERE game_id = @id", conn);
                cmd.Parameters.AddWithValue("id", r.GameId);
                await cmd.ExecuteNonQueryAsync();
            }
            else await Save(r.GameId, g);
        }
        return new ExitResponse { Success = true };
    }

    public override async Task<GameResponse> MakeMove(MoveRequest r, ServerCallContext c)
    {
        var g = await Load(r.GameId);
        if (g == null) return new GameResponse { Error = "Комната не найдена" };
        lock (g)
        {
            if (g.ValidMove(r.BoardX, r.BoardY, r.CellX, r.CellY, r.PlayerId))
                g.MakeMove(r.BoardX, r.BoardY, r.CellX, r.CellY);
        }
        await Save(r.GameId, g);
        return Map(r.GameId, g);
    }

    public override async Task<GameResponse> GetState(StateRequest r, ServerCallContext c)
    {
        var g = await Load(r.GameId);
        return g != null ? Map(r.GameId, g) : new GameResponse { Error = "Not found" };
    }

    private async Task Save(string id, UltimateGameLogic g)
    {
        using var conn = new NpgsqlConnection(ConnStr);
        await conn.OpenAsync();
        var sql = @"INSERT INTO games (game_id, cells, small_winners, active_board_x, active_board_y, player_x, player_o, is_x_turn, status)
                    VALUES (@id, @c, @sw, @ax, @ay, @px, @po, @t, @s)
                    ON CONFLICT (game_id) DO UPDATE SET cells=@c, small_winners=@sw, active_board_x=@ax, active_board_y=@ay, player_x=@px, player_o=@po, is_x_turn=@t, status=@s";
        using var cmd = new NpgsqlCommand(sql, conn);
        cmd.Parameters.AddWithValue("id", id);
        cmd.Parameters.AddWithValue("c", new string(g.Cells));
        cmd.Parameters.AddWithValue("sw", new string(g.SmallWinners));
        cmd.Parameters.AddWithValue("ax", g.ActiveBoardX);
        cmd.Parameters.AddWithValue("ay", g.ActiveBoardY);
        cmd.Parameters.AddWithValue("px", g.PlayerX ?? "");
        cmd.Parameters.AddWithValue("po", g.PlayerO ?? "");
        cmd.Parameters.AddWithValue("t", g.IsXTurn);
        cmd.Parameters.AddWithValue("s", g.Status);
        await cmd.ExecuteNonQueryAsync();
    }

    private async Task<UltimateGameLogic?> Load(string id)
    {
        try
        {
            using var conn = new NpgsqlConnection(ConnStr);
            await conn.OpenAsync();
            using var cmd = new NpgsqlCommand("SELECT cells, small_winners, active_board_x, active_board_y, player_x, player_o, is_x_turn, status FROM games WHERE game_id=@id", conn);
            cmd.Parameters.AddWithValue("id", id);
            using var dr = await cmd.ExecuteReaderAsync();
            if (await dr.ReadAsync()) return new UltimateGameLogic
            {
                Cells = dr.GetString(0).ToCharArray(),
                SmallWinners = dr.GetString(1).ToCharArray(),
                ActiveBoardX = dr.GetInt32(2),
                ActiveBoardY = dr.GetInt32(3),
                PlayerX = dr.GetString(4),
                PlayerO = dr.GetString(5),
                IsXTurn = dr.GetBoolean(6),
                Status = dr.GetString(7)
            };
        }
        catch { }
        return null;
    }

    private GameResponse Map(string id, UltimateGameLogic g, string err = "") => new GameResponse
    {
        GameId = id,
        FullBoard = new string(g.Cells),
        SmallBoardWinners = new string(g.SmallWinners),
        CurrentPlayerId = (g.IsXTurn ? g.PlayerX : g.PlayerO),
        Status = g.Status,
        ActiveBoardX = g.ActiveBoardX,
        ActiveBoardY = g.ActiveBoardY,
        Error = err,
        PlayerX = g.PlayerX ?? "",
        PlayerO = g.PlayerO ?? ""
    };
}
</file>

<file path="TicTacToeServer/TicTacToeServer.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <!-- Изменено с net10.0 на net9.0 -->
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Consul" Version="1.7.14.9" />
    <PackageReference Include="Grpc.AspNetCore" Version="2.60.0" />
    <PackageReference Include="Npgsql" Version="10.0.1" />
  </ItemGroup>

  <ItemGroup>
    <Protobuf Include="Protos\GameService.proto" GrpcServices="Server" Link="Protos\GameService.proto" />
  </ItemGroup>

</Project>
</file>

</files>
